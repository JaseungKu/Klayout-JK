<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
import math

"""
Usage: Click "Instance" icon. Choose "Jaseung_library" and then "cell".
"""

class MakeCPW(pya.PCellDeclarationHelper):
  """
  The PCell declaration for a CPW
  """

  def __init__(self):

    # Important: initialize the super class
    super(MakeCPW, self).__init__()

    # declare the parameters
#    self.param("l", self.TypeLayer, "Layer", default = pya.LayerInfo(1, 0))
    self.param("p", self.TypeLayer, "CPW Path Layer", default = pya.LayerInfo(0, 2))
    self.param("k", self.TypeLayer, "Keepout Layer", default = pya.LayerInfo(0, 1))
    self.param("c", self.TypeLayer, "CPW Layer", default = pya.LayerInfo(1, 0))
    self.param("i", self.TypeLayer, "Image BBox Layer", default = pya.LayerInfo(0, 3))
#    self.param("s", self.TypeShape, "", default = pya.Path.new())
   
    self.param("name", self.TypeString, "CPW Name", default='CPW')
     
    # parameter in um 
    self.param("cr", self.TypeDouble, "center conductor radius", default = 100)
    self.param("cw", self.TypeDouble, "c.c width", default = 10)
    self.param("gw", self.TypeDouble, "gap width", default = 6)
    self.param("kw", self.TypeDouble, "keepout width", default = 4)
    self.param("n", self.TypeInt, "Number of points per 360 degree", default = 72)     
    
    self.param("tl", self.TypeDouble, "CPW total length", default = 8000)
    self.param("numq", self.TypeInt, "Number of quarter turns (even num&gt;=6)", default =12)
    self.param("bh", self.TypeDouble, "Bounding box height", default = 1600)
    self.param("bw", self.TypeDouble, "Bounding box width", default = 1000)
    self.param("xs", self.TypeDouble, "x-coord. of start point", default = 10)
    self.param("xe", self.TypeDouble, "x-coord. of end point", default = 10)
    
    # this hidden parameter is used to determine whether the radius has changed
    # or the "s" handle has been moved
    #self.param("ru", self.TypeDouble, "Radius", default = 0.0, hidden = True)
    #self.param("rd", self.TypeDouble, "Double radius", readonly = True)

  def display_text_impl(self):
    # Provide a descriptive text for the cell
  #  return "MakeCPW(length=" + str(self.tl) + ",gap width=" + ('%.3f' % self.gw) + ")"
    return self.name
    
  def coerce_parameters_impl(self):
  
    # We employ coerce_parameters_impl to decide whether the handle or the 
    # numeric parameter has changed (by comparing against the effective 
    # radius ru) and set ru to the effective radius. We also update the 
    # numerical value or the shape, depending on which one has not changed.
   
   # rs = None
   # if isinstance(self.s, pya.DPoint): 
   #   # compute distance in micron
   #   rs = self.s.distance(pya.DPoint(0, 0))
   # if rs != None and abs(self.r-self.ru) &lt; 1e-6:
   #   self.ru = rs
   #   self.r = rs 
   # else:
   #   self.ru = self.r
   #   self.s = pya.DPoint(-self.r, 0)
   # 
   # self.rd = 2*self.r
    
    # n must be larger or equal than 9
   # if self.n &lt;= 9:
   #   self.n = 9


   # cr must be smaller than the length of each segment. segment is the line connecting two ajacent 
    
    # number of quarter turns must be even, and equal or larger than 6.
    if self.numq % 2 == 1:
      self.numq = self.numq -1  
    
    if self.numq &lt;6:
      self.numq = 6
      
    # Bounding box height must be larger than N * r.
    while self.numq * self.cr &gt; self.bh:
      self.numq += -2
    
    # width of meander should be larger than 4 times radius
    path_len = self.tl + (2-math.pi/2) * self.cr * self.numq
    meander_height = self.numq * self.cr
    extra_len = self.bh - meander_height
    
    # find width of meander, W
    W = (path_len - extra_len - self.numq * self.cr - math.fabs(self.xs) - math.fabs(self.xe)) / (self.numq/2-1)
    
    if 4 * self.cr &gt; W:
      self.cr = W / 4
          
  def can_create_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we can use any shape which 
    # has a finite bounding box
    return self.shape.is_box() or self.shape.is_polygon() or self.shape.is_path()
  
  #def parameters_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we set r and l from the shape's 
    # bounding box width and layer
    # self.tmp = self.shape.bbox().width() * self.layout.dbu / 2
    #self.l = self.layout.get_info(self.layer)
    #self.s = self.shape.path # read selected path obj.
                      
  #def transformation_from_shape_impl(self):
    # Implement the "Create PCell from shape" protocol: we use the center of the shape's
    # bounding box to determine the transformation
    #return pya.Trans(self.shape.bbox().center())
       
  def produce_impl(self):
  
    # This is the main part of the implementation: create the layout
                                                                                                                                                                                                                                                                                                    
    # fetch the parameters
    #ru_dbu = self.ru / self.layout.dbu

    # compute the circle
    #pts = []
    #da = math.pi * 2 / self.n
    #for i in range(0, self.n):
    #  pts.append(pya.Point.from_dpoint(pya.DPoint(ru_dbu * math.cos(i * da), ru_dbu * math.sin(i * da))))
    
    # create the shape
    #self.cell.shapes(self.l_layer).insert(pya.Polygon(pts))

#    self.s.width = self.cr / self.layout.dbu
#    self.cell.shapes(self.l_layer).insert(self.s)
    
    # Here comes my code
    
    # change actual dimension to database unit.
    cr_dbu = self.cr / self.layout.dbu
    cw_dbu = self.cw / self.layout.dbu
    gw_dbu = self.gw / self.layout.dbu
    kw_dbu = self.kw / self.layout.dbu
    
    tl_dbu = self.tl / self.layout.dbu
    numq_dbu = self.numq / self.layout.dbu
    bh_dbu = self.bh / self.layout.dbu
    bw_dbu = self.bw / self.layout.dbu
    xs_dbu = self.xs / self.layout.dbu
    xe_dbu = self.xe / self.layout.dbu
    
    cr_inner_dbu = cr_dbu - 0.5 * cw_dbu  # Inner radius of center conductor
    cr_outer_dbu = cr_dbu + 0.5 * cw_dbu  # Outer radius of center conductor
    gap_inner_dbu = cr_inner_dbu - gw_dbu
    gap_outer_dbu = cr_outer_dbu + gw_dbu
    keepout_inner_dbu = gap_inner_dbu - kw_dbu
    keepout_outer_dbu = gap_outer_dbu + kw_dbu
    
    # create a path
    cc_path = self.create_path()
        
    # create two more paths : gap and keepout
    gap_path = cc_path.dup()
    keepout_path = cc_path.dup()
    
    cc_path.width = cw_dbu
    gap_path.width = cc_path.width + gw_dbu * 2.0
    keepout_path.width = gap_path.width + kw_dbu * 2.0
    
    # round path
    cc_path_rounded = self.roundpath(cc_path)
    gap_path_rounded = self.roundpath(gap_path)
    keepout_path_rounded = self.roundpath(keepout_path)
        
    # path to region
    cc_region = pya.Region.new(cc_path_rounded)
    gap_region = pya.Region.new(gap_path_rounded)
    keepout_region = pya.Region.new(keepout_path_rounded)
   
    # create shape
    self.cell.shapes(self.p_layer).insert(cc_path)
    self.cell.shapes(self.p_layer).insert(cc_region)
    self.cell.shapes(self.c_layer).insert(gap_region - cc_region)
    self.cell.shapes(self.k_layer).insert(keepout_region)

    # create an image bounding box in "Image BBox" layer, based on the given height and width
    lower_left_x, lower_left_y = -bw_dbu/2.0, -bh_dbu/2.0
    upper_right_x, upper_right_y = bw_dbu/2.0, bh_dbu/2.0
    ibbox = pya.Box.new(lower_left_x, lower_left_y, upper_right_x, upper_right_y)
  
    self.cell.shapes(self.i_layer).insert(ibbox)
    
  def create_path(self):
  # I assume the path is centered with respect to origin (0,0)
    cr_dbu = self.cr / self.layout.dbu
    xe_dbu = self.xe / self.layout.dbu
    xs_dbu = self.xs / self.layout.dbu
    bh_dbu = self.bh / self.layout.dbu
    
    path_len = self.tl + (2.0-math.pi/2.0) * self.cr * self.numq
    path_len_dbu = path_len / self.layout.dbu
    
    meander_height = self.numq * self.cr
    extra_len = self.bh - meander_height
    meander_height_dbu = self.numq * cr_dbu # height of meander with numq turns.
    extra_len_dbu = bh_dbu - meander_height_dbu
    
    # find width of meander, W
    W = (path_len - extra_len - self.numq * self.cr - (math.fabs(self.xs)+ self.sign(self.xs)*(-1)**(self.numq //2)*self.xe)) / (self.numq/2-1)
    W_dbu = W / self.layout.dbu
    
    pts = []
    delta = [] # delta vector
    
    if self.xs &gt;= 0:
      startsign = -1
    else:
      startsign = 1
      
    delta.append(pya.Point.new(0, cr_dbu))
    delta.append(pya.Point.new(W_dbu /2 * startsign - xs_dbu, 0))
    
    for i in range(2, self.numq - 1):
      if i % 2 == 0:
        delta.append(delta[0] * 2)
      else:
        delta.append(pya.Point.new(W_dbu,0) * startsign * (-1)**(i//2))

    delta.append(pya.Point.new (xe_dbu - W_dbu / 2 * (-1)**(self.numq/2) * startsign, 0))
    delta.append(pya.Point.new(0, cr_dbu))
    
    # create meander path except extra length
    pts.append(pya.Point.new(xs_dbu, -meander_height_dbu/2))
    for i in range(0, self.numq+1):
      pts.append(pts[i] + delta[i])
      
    # add extra length 
    pts.insert(0, pya.Point.new(xs_dbu, -meander_height_dbu/2 - extra_len_dbu/2))
#    pts.append(pya.Point.new(xe_dbu, meander_height_dbu/2 + extra_len_dbu/2))
    pts.append(pts[-1] + pya.Point.new(0, extra_len_dbu/2))
    
    createdpath = pya.Path.new(pts,1)  
  
    return createdpath
  
  def sign(self, x):
    if x&gt;=0:
      return 1
    else:
      return -1  
      
  def roundpath(self, p):
    rounded_path = p.dup() # to be returned.  p is path.
    
    path_pnt = []
    for point in p.each_point():
      path_pnt.append(point)
      
    rounded_path_pnt = []
    rounded_path_pnt.append(path_pnt[0])
      
    n = p.num_points()
    for i in range(1, n-1):
      x1, y1 = path_pnt[i-1].x, path_pnt[i-1].y
      x2, y2 = path_pnt[i].x, path_pnt[i].y
      x3, y3 = path_pnt[i+1].x, path_pnt[i+1].y
      
      if (x1==x2 and x2==x3) or (y1==y2 and y2==y3):
        rounded_section = [pya.Point(x2,y2)]
      else:
        rounded_section = self.get_rounded_section(x1, y1, x2, y2, x3, y3) # list of point
        
      rounded_path_pnt = rounded_path_pnt + rounded_section
      
    rounded_path_pnt.append(path_pnt[-1]) # add last point of path p.
#    print(rounded_path_pnt)
    rounded_path = pya.Path.new(rounded_path_pnt, p.width)

    return rounded_path

  def get_rounded_section(self, x1, y1, x2, y2, x3, y3): # return a list of points
    def sign(x):
      if x &gt; 0:
        return 1
      elif x&lt;0:
        return -1
      else:
        return 0
        
    pts = []
    da = 2 * math.pi / self.n

    r = self.cr /self.layout.dbu
   
    if y1 == y2:
      for i in range(0, int(self.n / 4) + 1):
        xi = x2 + r * sign(x1-x2) + r * math.cos(da * i * sign(x1-x2) * sign(y2-y3) + math.pi/2*sign(y2-y3))
        yi = y2 + r * sign(y3-y2) + r * math.sin(da * i * sign(x1-x2) * sign(y2-y3) + math.pi/2*sign(y2-y3))
        pts.append(pya.Point.from_dpoint(pya.DPoint(xi, yi)))
        
    else :
      for i in range(0, int(self.n / 4) + 1):
        xi = x2 + r * sign(x3-x2) + r * math.cos(da * i * sign(x2-x3) * sign(y2-y1) + math.pi/2*sign(x3-x2) + math.pi/2)
        yi = y2 + r * sign(y1-y2) + r * math.sin(da * i * sign(x2-x3) * sign(y2-y1) + math.pi/2*sign(x3-x2) + math.pi/2)
        pts.append(pya.Point.from_dpoint(pya.DPoint(xi, yi)))

    return pts
        

</text>
</klayout-macro>
